#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     htGyro,         sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     motor3,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor1,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motor4,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motor2,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorLArm,     tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorRArm,     tmotorNormal, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "HTGYRO-driver.h"

#define mBackLeft motor[motor1]
#define mBackRight motor[motor2]
#define mFrontLeft motor[motor3]
#define mFrontRight motor[motor4]
#define mRArm motor[motorRArm]
#define mLArm motor[motorLArm]

#define joyX joystick.joy1_x1
#define joyY joystick.joy1_y1
#define joyRot joystick.joy1_x2
#define threshX (abs(joyX) > 6 ? true:false)
#define threshY (abs(joyY) > 6 ? true:false)
#define threshRot (abs(joyRot) > 6 ? true:false)

float robotAngle = 0;
float lastTime = 0;
bool fieldOriented = true;
//0.75 1.00 1.25
void calculateGyro()
{
  if(abs(HTGYROreadRot(S2)) > 1.0)
  {
    robotAngle += (nPgmTime - lastTime) * HTGYROreadRot(S2) / (1000);
  }
  lastTime = nPgmTime;
}

float getTheta(int x, int y)
{
  return atan2(x, y);
}

float getMagnitude(int x, int y)
{
  return sqrt(pow(x,2)+pow(y,2)) / 181.019336;
}

float getRotation(int x)
{
  return ((float)x)/128;
}

void stopMotors()
{
  mBackLeft = 0;
  mBackRight = 0;
  mFrontLeft = 0;
  mFrontRight = 0;
}

void computeMovement()
{
  getJoystickSettings(joystick);
  if(!threshX && !threshY && !threshRot) {stopMotors(); return;}

  float th = getTheta(joyX, joyY);
  float v = getMagnitude(joyX, joyY);
  float rot = getRotation(joyRot);
  float gyr = degreesToRadians(robotAngle) - (fieldOriented ? 0 : degreesToRadians(robotAngle));
  float mBackLeftTmp = (cos(th+(PI/4)-gyr)*v - rot/(1.5));
  float mFrontRightTmp = (cos(th+(PI/4)-gyr)*v + rot/1.5);
  float mBackRightTmp = -1 * (sin(th+(PI/4)-gyr)*v - rot/1.5);
  float mFrontLeftTmp = -1 * (sin(th+(PI/4)-gyr)*v + rot/1.5);

  float max = 1;
  if(abs(mBackLeftTmp) > abs(max)) max = mBackLeftTmp;
  if(abs(mFrontRightTmp) > abs(max)) max = mFrontRightTmp;
  if(abs(mBackRightTmp) > abs(max)) max = mBackRightTmp;
  if(abs(mFrontLeftTmp) > abs(max)) max = mFrontLeftTmp;
  max = abs(max);

  mBackLeft = 100 * mBackLeftTmp / max;
  mFrontRight = 100 * mFrontRightTmp / max;
  mBackRight = 100 * mBackRightTmp / max;
  mFrontLeft = 100 * mFrontLeftTmp / max;
}

bool lastStateDown = false;
void checkButtons()
{
  if(joy1Btn(2)) {HTGYROstartCal(S2); PlaySound(soundBeepBeep);}
  
  if(joy1Btn(3) && !lastStateDown) {fieldOriented = !fieldOriented;}
  if(!joy1Btn(3)) {lastStateDown = false;}
  
  if(joy1Btn(5)) {mRArm =  80; mLArm = -80;}
  if(joy1Btn(6)) {mRArm = -80; mLArm =  80;}
  if(!joy1Btn(5) && !joy1Btn(6)) {mRArm = 0; mLArm = 0;}
}

task main()
{
  HTGYROstartCal(S2);
  lastTime = nPgmTime;

  while(true)
  {
    computeMovement();
    //nxtDisplayTextLine(5, ""+(nPgmTime - lastTime));
    calculateGyro();
    checkButtons();
    //nxtDisplayTextLine(3, ""+HTGYROreadRot(S2));
    //nxtDisplayTextLine(4, ""+robotAngle);
    wait1Msec(2);
  }
}
