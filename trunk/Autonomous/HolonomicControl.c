#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     htGyro,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     htInfraL,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     htInfraR,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motor2,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motor4,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motor3,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motor1,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "HTGYRO-driver.h"
//#include "HTIRS2-driver.h"

#define mBackLeft motor[motor1]
#define mBackRight motor[motor2]
#define mFrontLeft motor[motor3]
#define mFrontRight motor[motor4]
#define joyX joystick.joy1_x1
#define joyY joystick.joy1_y1
#define joyRot joystick.joy1_x2
#define threshX (abs(joyX) > 6 ? true:false)
#define threshY (abs(joyY) > 6 ? true:false)
#define threshRot (abs(joyRot) > 6 ? true:false)

float robotRotation = 0;
float robotTheta = 0;
float robotMagnitude = 0;

float robotAngle = 0;
float lastTime = 0;
//0.75 1.00 1.25
void calculateGyro()
{
  if(abs(HTGYROreadRot(S2)) > 1.0)
  {
    robotAngle += (nPgmTime - lastTime) * HTGYROreadRot(S2) / (1000);
  }
  lastTime = nPgmTime;
}

float getTheta(int x, int y)
{
  return atan2(x, y);
}

float getMagnitude(int x, int y)
{
  return sqrt(pow(x,2)+pow(y,2)) / 181.019336;
}

float getRotation(int x)
{
  return ((float)x)/128;
}

void stopMotors()
{
  mBackLeft = 0;
  mBackRight = 0;
  mFrontLeft = 0;
  mFrontRight = 0;
}

void computeMovement()
{
  //if(!threshX && !threshY && !threshRot) {stopMotors(); return;}

  float th = robotTheta;
  float v = robotMagnitude;
  float rot = robotRotation;
  float gyr = degreesToRadians(robotAngle);

  float mBackLeftTmp = (cos(th+(PI/4)-gyr)*v - rot/(1.5));
  float mFrontRightTmp = (cos(th+(PI/4)-gyr)*v + rot/1.5);
  float mBackRightTmp = -1 * (sin(th+(PI/4)-gyr)*v - rot/1.5);
  float mFrontLeftTmp = -1 * (sin(th+(PI/4)-gyr)*v + rot/1.5);

  float max = 1;
  if(abs(mBackLeftTmp) > abs(max)) max = mBackLeftTmp;
  if(abs(mFrontRightTmp) > abs(max)) max = mFrontRightTmp;
  if(abs(mBackRightTmp) > abs(max)) max = mBackRightTmp;
  if(abs(mFrontLeftTmp) > abs(max)) max = mFrontLeftTmp;
  max = abs(max);

  mBackLeft = 100 * mBackLeftTmp / max;
  mFrontRight = 100 * mFrontRightTmp / max;
  mBackRight = 100 * mBackRightTmp / max;
  mFrontLeft = 100 * mFrontLeftTmp / max;
}

task autonomousSequence()
{
  robotRotation = 0;
}

task main()
{
  HTGYROstartCal(S2);
  lastTime = nPgmTime;
  bDisplayDiagnostics = false;
  StartTask(autonomousSequence);

  while(true)
  {
    computeMovement();
    //nxtDisplayTextLine(5, ""+(nPgmTime - lastTime));
    calculateGyro();
    //nxtDisplayTextLine(3, ""+HTGYROreadRot(S2));
    nxtDisplayTextLine(3, "R: "+SensorValue(htInfraR));
    nxtDisplayTextLine(4, "L: "+SensorValue(htInfraL));
    nxtDisplayTextLine(5, ""+robotAngle);
    abortTimeslice();
    wait1Msec(5);
  }
}
