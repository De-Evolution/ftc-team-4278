#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S2,     htGyro,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S4_C1_1,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorFL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorAmrL,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     motorAmrR,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     motorBR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_2,     motorFR,       tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-gyro.h"
#include "ArmControl.h"
#include "hitechnic-sensormux.h"
#include "hitechnic-colour-v2.h"
#include "hitechnic-irseeker-v2.h"

#define mBackLeft motor[motorBL]
#define mBackRight motor[motorBR]
#define mFrontLeft motor[motorFL]
#define mFrontRight motor[motorFR]
#define mAmrR motor[motorAmrR]
#define mAmrL motor[motorAmrL]

#define joyX joystick.joy1_x1
#define joyY joystick.joy1_y1
#define joyRot joystick.joy1_x2
#define threshX (abs(joyX) > 6 ? true:false)
#define threshY (abs(joyY) > 6 ? true:false)
#define threshRot (abs(joyRot) > 6 ? true:false)

float robotAngle = -45;
float lastTime = 0;
bool fieldOrientation = true;
int sensitivity = 1;

void calculateGyro() {
	if(abs(HTGYROreadRot(S2)) > 1.0) robotAngle += (nPgmTime - lastTime) * HTGYROreadRot(S2) / (1000);
	lastTime = nPgmTime;
}

float getTheta(int x, int y) {
	return atan2(y,x);
}

float getMagnitude(int x, int y) {
	return sqrt(pow(x,2)+pow(y,2)) / 181.019336;
}

float getRotation(int x) {
	return ((float)x)/128;
}

void stopMotors() {
	mBackLeft = 0;
	mBackRight = 0;
	mFrontLeft = 0;
	mFrontRight = 0;
}

void computeMovement() {
	getJoystickSettings(joystick);

	int x = joystick.joy1_x1;
	int y = joystick.joy1_y1;

	x = (abs(x) > 15 ? x : 0);
    y = (abs(y) > 15 ? y : 0);

    mBackLeft = -(y + x);
    mFrontLeft = -(y + x);
    mBackRight = -(y - x);
    mFrontRight = -(y - x);
}

bool armTaskRunning = false;

void StopArmTasks() {
	armTaskRunning = false;
	StopTask(armLow);
	StopTask(armMid);
	StopTask(armHi);
}

void checkButtons() {
	if(joy1Btn(10)) {HTGYROstartCal(S2); robotAngle = 0;}
	if(joy1Btn(5)) {StopArmTasks(); mAmrR = -10; mAmrL = -10;}
	if(joy1Btn(6)) {StopArmTasks(); mAmrR =  55; mAmrL =  55;}
	if(joy1Btn(7)) {StopArmTasks(); mAmrR = -10; mAmrL = -10;}
	if(joy1Btn(8)) {StopArmTasks(); mAmrR =  10; mAmrL =  10;}
	if(!joy1Btn(5) && !joy1Btn(6) && !joy1Btn(7) && !joy1Btn(8) && !armTaskRunning) {mAmrR = 0; mAmrL = 0;}
	if(joy1Btn(2)) {fieldOrientation = true; nxtDisplayTextLine(2, "True ");}
	if(joy1Btn(4)) {fieldOrientation = false; nxtDisplayTextLine(2, "False");}
	if(joy1Btn(1)) sensitivity = 2;
	if(joy1Btn(3)) sensitivity = 1;
	//if(joystick.joy1_TopHat == 6) {StartTask(armLow); armTaskRunning = true;}
	//if(joystick.joy1_TopHat == 2) {StartTask(armMid); armTaskRunning = true;}
	//if(joystick.joy1_TopHat == 0) {StartTask(armHi); armTaskRunning = true;}
	if(joystick.joy1_TopHat == 6) {hogCPU(); StopArmTasks(); armTaskRunning = true; StartTask(armLow); releaseCPU();}
	if(joystick.joy1_TopHat == 2) {hogCPU(); StopArmTasks(); armTaskRunning = true; StartTask(armMid); releaseCPU();}
	if(joystick.joy1_TopHat == 0) {hogCPU(); StopArmTasks(); armTaskRunning = true; StartTask(armHi);  releaseCPU();}
}

const tMUXSensor colorPort = msensor_S1_4;

task main() {
	clearDebugStream();

	HTGYROstartCal(S2);
	lastTime = nPgmTime;
	//bDisplayDiagnostics = false;
	//waitForStart();
	while(true) {
		computeMovement();
		calculateGyro();
		checkButtons();
		int _r, _g, _b, _d1, _d2, _d3, _d4, _d5;
		bDisplayDiagnostics = false;

		HTIRS2readAllACStrength(msensor_S1_2, _d1, _d2, _d3, _d4, _d5);
		HTCS2readRGB(colorPort, _r, _g, _b);
		nxtDisplayTextLine(3, "r:%i", _r);
		nxtDisplayTextLine(4, "g:%i", _g);
		nxtDisplayTextLine(5, "b:%i", _b);
		//nxtDisplayTextLine(3, "1:%i",HTIRS2readACDir(msensor_S1_1));
		//nxtDisplayTextLine(4, "2:%i",HTIRS2readACDir(msensor_S1_2));
		EndTimeSlice();
	}
}
