#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,	   htGyro,		   sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S4_C1_1,		motorBL,	   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,		motorFL,	   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,		motorF,		   tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,		motorArms,	   tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,		motorBR,	   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_2,		motorFR,	   tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard				 !!*//

#include "JoystickDriver.c"
#include "hitechnic-gyro.h"
#include "ArmControl.h"

#define mBackLeft motor[motorBL]
#define mBackRight motor[motorBR]
#define mFrontLeft motor[motorFL]
#define mFrontRight motor[motorFR]
#define mArm motor[motorArms]

#define joyX joystick.joy1_x1
#define joyY joystick.joy1_y1
#define joyRot joystick.joy1_x2
#define threshX (abs(joyX) > 6 ? true:false)
#define threshY (abs(joyY) > 6 ? true:false)
#define threshRot (abs(joyRot) > 6 ? true:false)

float robotAngle = 0;
float lastTime = 0;
bool fieldOrientation = true;
int sensitivity = 1;

void calculateGyro() {
	if(abs(HTGYROreadRot(S2)) > 1.0) robotAngle += (nPgmTime - lastTime) * HTGYROreadRot(S2) / (1000);
	lastTime = nPgmTime;
}

float getTheta(int x, int y) {
	return atan2(y,x);
}

float getMagnitude(int x, int y) {
	return sqrt(pow(x,2)+pow(y,2)) / 181.019336;
}

float getRotation(int x) {
	return ((float)x)/128;
}

void stopMotors() {
	mBackLeft = 0;
	mBackRight = 0;
	mFrontLeft = 0;
	mFrontRight = 0;
}

void computeMovement() {
	getJoystickSettings(joystick);
	if(!threshX && !threshY && !threshRot) {stopMotors(); return;}

	float th = getTheta(joyX, joyY);
	float v = getMagnitude(joyX, joyY);
	float rot = getRotation(joyRot);
	float gyr = (fieldOrientation?degreesToRadians(robotAngle):0);

	float mBackLeftTmp = (cos(th+(PI/4)-gyr)*v - rot/(1.5));
	float mFrontRightTmp = (cos(th+(PI/4)-gyr)*v + rot/1.5);
	float mBackRightTmp = -1 * (sin(th+(PI/4)-gyr)*v - rot/1.5);
	float mFrontLeftTmp = -1 * (sin(th+(PI/4)-gyr)*v + rot/1.5);

	float max = 1;
	if(abs(mBackLeftTmp) > abs(max)) max = mBackLeftTmp;
	if(abs(mFrontRightTmp) > abs(max)) max = mFrontRightTmp;
	if(abs(mBackRightTmp) > abs(max)) max = mBackRightTmp;
	if(abs(mFrontLeftTmp) > abs(max)) max = mFrontLeftTmp;
	max = abs(max) * sensitivity;

	mBackLeft = 100 * mBackLeftTmp / max;
	mFrontRight = 100 * mFrontRightTmp / max;
	mBackRight = 100 * mBackRightTmp / max;
	mFrontLeft = 100 * mFrontLeftTmp / max;
}

bool armTaskRunning = false;

void StopArmTasks() {
	armTaskRunning = false;
	StopTask(armLow);
	StopTask(armMid);
	StopTask(armHi);
}

void checkButtons() {
	if(joy1Btn(10)) {HTGYROstartCal(S2); robotAngle = 0;}
	if(joy1Btn(5)) {StopArmTasks(); mArm = (sensitivity == 1 ? 95 : 35);}
	if(joy1Btn(6)) {StopArmTasks(); mArm = (sensitivity == 1 ? -95 : -35);}
	if(!joy1Btn(5) && !joy1Btn(6) && !armTaskRunning) {mArm = 0;}
	if(joy1Btn(2)) {fieldOrientation = true; nxtDisplayTextLine(2, "True ");}
	if(joy1Btn(4)) {fieldOrientation = false; nxtDisplayTextLine(2, "False");}
	if(joy1Btn(1)) sensitivity = 2;
	if(joy1Btn(3)) sensitivity = 1;
	if(joystick.joy1_TopHat == 6) {hogCPU(); StopArmTasks(); armTaskRunning = true; StartTask(armLow); releaseCPU();}
	if(joystick.joy1_TopHat == 2) {hogCPU(); StopArmTasks(); armTaskRunning = true; StartTask(armMid); releaseCPU();}
	if(joystick.joy1_TopHat == 0) {hogCPU(); StopArmTasks(); armTaskRunning = true; StartTask(armHi);  releaseCPU();}
}

task main() {
	clearDebugStream();
	HTGYROstartCal(S2);
	lastTime = nPgmTime;
	//bDisplayDiagnostics = false;

	while(true) {
		computeMovement();
		calculateGyro();
		checkButtons();
		EndTimeSlice();
	}
}
