#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Motor,  mtr_S1_C1_1,     motorsLeft,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorsRight,   tmotorNormal, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    ,                     tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    ,                     tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Autonomous v2.0
#include "JoystickDriver.c"

float forward(float dist, float wheelRadius)
{
  float Pie = 3.14159;
  return (1440*dist)/(2*Pie*wheelRadius);
}

float turn(float wheelRadius, float distBtwnWheels, float degreesToTurn)
{
  return ((4*degreesToTurn*distBtwnWheels)/wheelRadius)/2;
}

task main()
{
  float wR = 2;
  float dBW = 16;
  nMotorEncoder[motorsLeft] = 0;
  nMotorEncoder[motorsRight] = 0;

  //Turn right
  nMotorEncoderTarget[motorsLeft] = turn(wR, dBW, 90);
  nMotorEncoderTarget[motorsRight] = -turn(wR, dBW, 90);

  motor[motorsLeft] = 50;
  motor[motorsRight] = -50;

  wait1Msec(2000);

  //Forward
  nMotorEncoder[motorsLeft] = 0;
  nMotorEncoder[motorsRight] = 0;

  nMotorEncoderTarget[motorsLeft] = 8000;
  nMotorEncoderTarget[motorsRight] = 8000;

  motor[motorsLeft] = 50;
  motor[motorsRight] = 50;

  wait1Msec(5000);
  motor[motorC] = 40;
  wait1Msec(1000);
}
