#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorsLeft,    tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorsRight,   tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorArm,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Autonomous v2.0
#include "JoystickDriver.c"

float forward(float dist, float wheelRadius)
{
  float Pie = 3.14159;
  return (1440*dist)/(2*Pie*wheelRadius);
}

float turn(float wheelRadius, float distBtwnWheels, float degreesToTurn)
{
  return ((4*degreesToTurn*distBtwnWheels)/wheelRadius)/2;
}

void makeFD(int dist, int power, float wR, float dBW)
{
  nMotorEncoder[motorsLeft] = 0;
  nMotorEncoder[motorsRight] = 0;

  nMotorEncoderTarget[motorsLeft] = forward(dist, wR);
  nMotorEncoderTarget[motorsRight] = forward(dist, wR);

  motor[motorsRight] = power;
  motor[motorsLeft] = power;
}

void makeRight(int degrees, int power, float wR, float dBW)
{
  nMotorEncoder[motorsLeft] = 0;
  nMotorEncoder[motorsRight] = 0;

  nMotorEncoderTarget[motorsLeft] = turn(wR, dBW, degrees);
  nMotorEncoderTarget[motorsRight] = -turn(wR, dBW, degrees);

  motor[motorsLeft] = power;
  motor[motorsRight] = -power;
}

void makeLeft(int degrees, int power, float wR, float dBW)
{
  nMotorEncoder[motorsLeft] = 0;
  nMotorEncoder[motorsRight] = 0;

  nMotorEncoderTarget[motorsLeft] = -turn(wR, dBW, degrees);
  nMotorEncoderTarget[motorsRight] = turn(wR, dBW, degrees);

  motor[motorsLeft] = -power;
  motor[motorsRight] = power;
}

task main()
{
  float wR = 2;
  float dBW = 18;

  makeFD(24, 25, wR, dBW);
  wait1Msec(3000);

  makeRight(90, 25, wR, dBW);
  wait1Msec(3000);

  makeFD(24, 25, wR, dBW);
  wait1Msec(3000);

  makeLeft(90, 25, wR, dBW);
  wait1Msec(3000);

  makeFD(120, 15, wR, dBW);
  wait1Msec(6000);

  nMotorEncoder[motorB] = 0;
  nMotorEncoderTarget[motorB] = 1440;

  motor[motorB] = 50;
  motor[motorC] = 50;
  wait1Msec(10000);
  motor[motorB] = 0;
  motor[motorC] = 0;

  motor[motorsLeft] = -30;
  motor[motorsRight] = -30;
  while(nMotorRunState[motorB] != true)
  {}

  motor[motorB] = 0;
  motor[motorC] = 0;

  motor[motorArm] = -30;
  wait1Msec(1000);
  for(int i; i<5; i++)
  {
  nMotorEncoder[motorB] = 0;
  nMotorEncoderTarget[motorB] = 360;

  motor[motorB] = 70;
  motor[motorC] = 70;

  while(nMotorEncoder[motorB] < 360) {}

  motor[motorB] = 0;
  motor[motorC] = 0;

  motor[motorsLeft] = -10;
  motor[motorsRight] = -10;
  wait1Msec(100);
  motor[motorsLeft] = 10;
  motor[motorsRight] = 10;
  wait1Msec(200);
  motor[motorsLeft] = 0;
  motor[motorsRight] = 0;
  }
}
